<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Friend Awards AR撮影</title>
  <style>
    body, html {
      margin: 0; padding: 0; height: 100%; overflow: hidden;
      font-family: sans-serif;
      background: black;
    }
    #camera {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      object-fit: cover;
      z-index: 0;
      transform: scaleX(-1);
    }
    #overlay {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 80vw;
      max-width: 400px;
      z-index: 1;
      pointer-events: none;
    }
    #shootBtn {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 2;
      padding: 12px 24px;
      background: #6b3e00;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 1.1rem;
    }
    #preview {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.9);
      justify-content: center; align-items: center;
      z-index: 10;
    }
    #preview img {
      max-width: 90vw;
      max-height: 90vh;
    }
  </style>
</head>
<body>

<video id="camera" autoplay playsinline muted></video>
<img id="overlay" src="award.png" alt="賞状" />
<button id="shootBtn">📸 ツーショット撮影</button>

<div id="preview">
  <img id="captured" />
</div>

<!-- オーバーレイ画像にドラッグ＆ピンチ対応 -->
<script>
    const camera = document.getElementById('camera');
    const overlay = document.getElementById('overlay');
    const preview = document.getElementById('preview');
    const captured = document.getElementById('captured');
  
    const params = new URLSearchParams(location.search);
    const imageUrl = params.get('img');
    if (imageUrl) {
      overlay.src = decodeURIComponent(imageUrl);
    }
  
    startCamera();
  
    async function startCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'user' }
        });
        camera.srcObject = stream;
      } catch (err) {
        alert('カメラへのアクセスが許可されませんでした。');
      }
    }
  
    document.getElementById('shootBtn').addEventListener('click', takeScreenshot);
    preview.addEventListener('click', () => preview.style.display = 'none');
  
    function takeScreenshot() {
      const canvas = document.createElement('canvas');
      canvas.width = camera.videoWidth;
      canvas.height = camera.videoHeight;
      const ctx = canvas.getContext('2d');
  
      ctx.translate(canvas.width, 0);
      ctx.scale(-1, 1);
      ctx.drawImage(camera, 0, 0, canvas.width, canvas.height);
  
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.src = overlay.src;
      img.onload = () => {
        const imgW = canvas.width * currentScale;
        const imgH = img.height * (imgW / img.width);
        const offsetX = canvas.width * currentX;
        const offsetY = canvas.height * currentY;
        ctx.drawImage(img, offsetX - imgW / 2, offsetY - imgH / 2, imgW, imgH);
        captured.src = canvas.toDataURL('image/png');
        preview.style.display = 'flex';
      };
    }
  
    // 🖐️ ドラッグ & ピンチ用の状態変数
    let isDragging = false;
    let startX = 0, startY = 0;
    let currentX = 0.5, currentY = 0.5;
    let currentScale = 1;
    let startDist = 0;
    let startScale = 1;
  
    function getTouchDist(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }
  
    overlay.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (e.touches.length === 1) {
        isDragging = true;
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
      } else if (e.touches.length === 2) {
        startDist = getTouchDist(e.touches);
        startScale = currentScale;
      }
    });
  
    overlay.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (e.touches.length === 1 && isDragging) {
        const dx = (e.touches[0].clientX - startX) / window.innerWidth;
        const dy = (e.touches[0].clientY - startY) / window.innerHeight;
        currentX += dx;
        currentY += dy;
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
      } else if (e.touches.length === 2) {
        const newDist = getTouchDist(e.touches);
        currentScale = Math.min(3, Math.max(0.3, startScale * newDist / startDist));
      }
      updateOverlayTransform();
    });
  
    overlay.addEventListener('touchend', (e) => {
      if (e.touches.length === 0) {
        isDragging = false;
      }
    });
  
    function updateOverlayTransform() {
      const x = currentX * 100;
      const y = currentY * 100;
      overlay.style.transform = `translate(-50%, -50%) translate(${x - 50}vw, ${y - 50}vh) scale(${currentScale})`;
    }
  
    updateOverlayTransform();
  </script>
  

</body>
</html>
